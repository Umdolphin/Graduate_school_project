---
title: Chapter2
author: 202140191 엄태훈
date: 2021-04-30(Fri)
# runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chap2 Data and Statistics  

통계의 역사는 꽤나 오래된 역사를 가지고 있지만, 본격적으로 통계학이라는 분야가 생겨난 것은 약 100~200년이라고 할 수 있다.   
과거에 통계학 분야는 따로 하나의 분야로 분류되지 않고, 통계는 대부분 수학의 일종으로 생각되었다.  

이러한 통계학은 현대사회에서 가장 핫한 주제 중 하나인 빅데이터와 연관되어 중요한 학문 중 하나로 활발히 연구되고 있다.   

한 정의에 따르면, 통계는 데이터로부터 결론을 모으고 분석하고 그리기 위한 기술이라고 설명되고 있다.  

통계 연구는 실험, 설문조사, 과거부터 쌓여온 데이터들 등의 관측치들을 모으고 요약하는 데에 크게 관련이 있다. 이러한 요약을 통해서 조사자는 폭넓은 타당성을 가지는 결과를 그릴 수 있다.   


## Types of Data
- Count data: 관측치가 음이 아닌 정수 값만 취할 수 있는 데이터이다. 
예를 들어, 동전 던지기에서 앞면의 개수 = {0,1,2,3...} 같은 데이터를 말한다.  

- Categorical data: 각각의 데이터가 뚜렷하여 범주로 나눌 수 있는 데이터이다.  
명목형 변수, 클래스 변수, 팩터라고도 불리며, 다양한 범주 또는 범주형 변수의 클래스를 수준이라고 부른다.  
Ex) 사람의 성별, 혈액형

```{r}
bloodtype = c("A","B","AB","O","AB","B")
data.frame(bloodtype)
```


- Ordered data: 데이터를 순위, 순서로 나열할 수 있는 데이터를 말한다.  
Ex) 대학교의 학점, 올림픽 순위


```{r}
country = c("KOREA","USA","UK","RUSSIA","JAPAN")
rank = as.numeric(c(1,3,5,4,2))
data.frame(country,rank)
```


- Interval Data: 데이터의 값이 그들 사이에 구간으로 나타낼 수 있지만 비율 관계는 없는 데이터를 말한다.  
EX) 온도  
```{r}
temp = c(36.0,18.0,36.0,28.0,43.0)
data.frame(temp)
```


- Ratio Data: 절대적 기준인 0이 존재하고 숫자 간의 비율이 산술적 의미를 가지는 데이터를 말한다.  
EX) 키, 몸무게  
```{r}
Name = c("JAMES","ALICE","JOHN","JANE","ANNA")
Height = c(175,160,183,165,185)
Weight = c(67,45,70,50,74)
data.frame(Name,Height,Weight)
```


### R 프로그램에서 데이터 사용하기 

R에서는 기본적으로 프로그램들 안에 내장돼 있는 데이터들이 있다.  이러한 데이터들은 특정 패키지를 불러오지 않고도 사용할 수 있거나, 특정 패키지를 불러와야 사용가능하다.  

기본적으로 R에 내장돼 있는 데이터들은 `data(데이터명)`을 입력하고 *데이터명*을 입력하면 불러올 수 있다.  



#### 특정 패키지 없이 데이터 불러오기

*iris* 데이터는 특정 패키지를 불러오지 않아도 기본적으로 사용 가능한 꽃의 정보에 대한 데이터이다.  

```{r}
data(iris)
head(iris,10)
```


#### 특정 패키지의 데이터 불러오기  

특정 패키지의 데이터를 불러오고자 하는 경우, 먼저 패키지를 설치하고 로드하는 과정을 거쳐야한다.  
`install.packages("패키지명")`을 통해 패키지를 설치한다.  
! 이때, 반드시 *"패키지명"*으로 해야한다. 패키지명에 ""을 붙이지 않으면 패키지 이름을 글자로 인식을 못하기 때문이다.  

패키지 설치를 완료하면, `library(패키지명)`을 통해 앞에서 설치한 패키지를 로드한다.  
-> *library*의 경우 "패키지명", 패키지명 두 방법 모두 인식한다.  

R에서 HH패키지에 들어있는 crime데이터를 불러와보자.    
HH패키지의 crime데이터는 음주자와 비음주자의 범죄 빈도를 비교한 데이터이다.  


```{r}
#install.packages("HH")
library(HH)
data(crime)
crime
```

## reshape2 패키지의 활용  

분석을 진행함에 있어 가장 시간을 많이 할애해야 하는 부분이면서 어려운 부분 중 하나가 바로 데이터를 전처리하는 것이다.  
데이터 전처리는 분석 프로젝트의 80%를 차지할 정도로 매우 중요한 부분이다.  
*데이터 전처리(Preprocessing)*은 데이터를 모델이 이해할 수 있는 형태로 변환 즉, 특정 분석에 적합하게 데이터를 가공하는 작업이다.   
대부분의 데이터셋은 생각하는 것만큼 분석을 하기에 편리하게 정렬되어 있지않기 때문에, 이러한 데이터 전처리 과정은 필수적 확인사항이다.  

R에서는 다양한 데이터 전처리 패키지를 제공하는데 그 중에서, `dplyr`, `reshpae2`패키지가 상당히 좋은 성능을 가지고 있다.  

`reshpae2`패키지는 데이터의 모양을 변환 할 때 유용하다.  

```{r}
# reshape2 패키지를 설치하고 로드한다.
# install.packages("reshape2")
library(reshape2)

wide <- data.frame(Names=LETTERS[1:5],x=1:5,y=6:10)
wide
```

*reshape2* 패키지에서는 `melt`와 `dcast`함수가 가장 많이 쓰인다.  

`melt`함수는 여러개의 칼럼을 한 컬럼에 세로로 정리할 때 사용된다.  
특정 변수를 식별자로 설정하고 나머지 변수들을 측정값의 칼럼으로 바꿀 수 있다.  


melt(데이터,id.vars,measure.vars)  
- *데이터*: melt에 적용할 데이터를 넣는다.  
- *id.vars*: 식별 칼럼명을 넣는다. 즉, 여러개의 칼럼이 하나로 만들어 질때 빼고싶은 칼럼명을 넣는다.  
- *measure.vars*: 하나의 칼럼으로 만들 여러개의 칼럼을 넣는다. id.vars에 칼럼을 지정해주면, measure.vars를 지정하지 않아도 자동으로 남은 칼럼은 measure.vars에 들어가게 된다.  


```{r}
long <- melt(wide,id.vars="Names") 
long 
```


`id.vars = "Names"`로 지정하여 Names를 식별자로 하고 나머지 *x*,*y*칼럼을 variable이라는 한 칼럼으로 정리를 하였다.  
`id.vars`를 입력하였기 때문에, `measure.vars`에 자동으로 *x*,*y*칼럼이 들어간것을 확인할 수 있다.  


```{r}
melt(wide,id.vars=c("Names","x"))
```


식별자를 2개로 설정하는 경우, c()를 이용하여 넣어줘어야 한다.  
식별자가 *Names*,*x* 두 개로 설정되어 *y* 칼럼에 대해서만 측정값을 나눈 것을 확인할 수 있다.  

***

`melt`함수가 여러개의 칼럼을 하나의 칼럼으로 좁게 변환했다면, `dcast`함수는 하나의 칼럼을 여러개의 칼럼으로 넓게 변환할 수 있다.  


dcast(데이터,Formula,value)
- *데이터*: dcast 함수를 적용할 데이터를 넣는다.  
- *Formula*: *식별 칼럼명 ~ 하나로 뭉친 칼럼명*의 형태로 넣는다.  
- *value:* 데이터의 값을 가지고있는 칼럼을 넣는다.  

```{r}
wideagain <- dcast(data=long,Names~variable,value="value") 
wideagain
```

`dcast`함수를 통해 *Names* 변수를 식별자로 고정하고 *variable*변수를 여러개의 칼럼으로 구분되게 Formula를 설정하였다.  
데이터의 값을 가지고 있는 *value*를 value로 설정한 것을 확인할 수 있다.  
`melt`함수를 통해 하나의 칼럼으로 변환했던 데이터가 `dcast`함수를 통해 여러개의 칼럼으로 구분된 것을 확인할 수 있다.  

## dplyr 패키지의 활용

`dplyr`패키지의 경우 데이터 전처리와 조작에서 최고의 성능을 가진다고 해도 과언이 아니다.  
많은 R 코드를 살펴보면 *%>%*라는 표시를 심심치 않게 볼 수 있는데, 이는 dplyr 패키지에서 사용되는 것이다.  
%>%를 통해 스텝을 정리해주기 때문에, 가독성 또한 높아지는 것을 확인할 수 있다.  
dplyr 패키지를 사용하기 위해서는 보통 원하는 데이터를 입력한 후, %>%(파이프라인)을 해주고 전처리 작업을 진행한다.  

`dplyr`의 *select* 함수를 이용하면 데이터에서 원하는 칼럼만을 추출하여 가져올 수 있다.  

```{r}
library(dplyr)
data(iris)

iris %>%
  select(Sepal.Width,Sepal.Length)
```

`dplyr`의 *filter*함수를 이용하면 조건에 맞는 행만을 추출하여 가져올 수 있다.

```{r}
iris %>% 
  filter(Sepal.Width >3)
```

`dplyr`의 *group_by*함수는 원하는 그룹 변수에 따라 계산을 할 수 있게 해준다.  
그룹으로 묶은 후, *summarise* 함수를 통해, 그룹에 따른 원하는 통계량을 계산할 수 있다.  


```{r}
iris$Sepal.Width
iris %>% 
  group_by(Species) %>% 
  summarise(Sepal_Width_m = mean(Sepal.Width),
            Sepal_Length_m = mean(Sepal.Length))
```

*group_by*를 통해 iris 데어터의 꽃의 종류에 따라 데이터를 묶은 후, 
*summarise*를 통해 꽃의 종류별로 평균을 구한 것을 확인할 수 있다.  


```{r}
iris %>% 
  group_by(Species) %>% 
  summarise(count=n())

```

*summarise(count=n())*을 지정해주면 그룹에 따른 빈도 수를 구할 수도 있다.  

***

## 결측치의 처리

NA가 하나라도 데이터의 존재하면 수치적인 계산을 진행하지 못한다.  

```{r}
ab = c(1:6,NA)
mean(ab)
```

이때,`na.rm =TRUE` 옵션을 통해 결측치를 제거하고 계산을 진행할 수 있다.    

```{r}
mean(ab,na.rm=TRUE)
```

`na.rm = TRUE` 옵션을 지정해준 결과, 결측치가 자동으로 제거되고 평균을 구하는 것을 알 수 있다.  

***

계산을 진행하기 전, NA값을 제거하고 싶은 경우, `na.omit()`함수를 이용하여 결측치를 제거할 수 있다.  

```{r}
cd = na.omit(ab)
cd
```

***

# Summary of Chapter2

* 현대는 과거보다 데이터가 셀 수 없이 늘어난 **빅데이터의 시대**라고 불리고 있다. 이러한 시대에서 이론적인 지식도 상당히 중요하게 여겨지고 있지만, 이론적 지식과 얻어진 데이터를 분석하고 정리하는 능력 또한 매우 중요한 능력 중 하나로 여겨진다. 따라서, 이론적인 지식과 **R,Python,SPSS,SAS**등과 같은 통계적인 분석 프로그램의 지식을 쌓는 것도 상당히 중요한 부분을 차지하고 있다.  

* 일반적으로 통계에서 측정척도는 **명목척도, 서열척도, 구간척도, 비율척도** 4가지로 나뉜다.  
-> **명목척도**: 측정대상을 고유한 특성에따라 분류한 것.  
-> **서열척도**: 측정대상을 순서 혹은 순위에 따라 분류한 것.  
-> **구간척도**: 측정대상이 가지고 있는 간격으로 수치를 부여한 것. 절대0점이 존재하지 않는다.  
-> **비율척도**: 측정대상의 비율에 대한 수치를 부여한 것. 절대0점이 존재한다.  

* 분석을 진행하고자 할때, 우리가 사용할 데이터의 형태가 분석을 진행하기에 적합하지 않은 경우가 종종 발생한다. 이러한 문제를 해결하는 방법이 바로 **데이터 전처리(Preprocessing)**이다. **Preprocessing**은 데이터를 분석에 적용할 수 있게 적합한 형태로 바꾸는 과정을 말한다.  

* 데이터 전처리 과정은 분석 프로젝트 시간 중, 70~80%의 시간을 소비하는 작업이라고 할 정도로 가장 중요한 작업으로 여겨진다. 전처리를 어떻게 진행하는지에 따라서 분석 결과가 달라질수도 있다.    

* 데이터 전처리 중 고려해야 하는 요소 중 하나이며, 분석을 방해하는 요소로 **이상치, 결측치**가 있다. **이상치**는 데이터가 있지만 평균값보다 훨씬 높은 값을 가지거나 낮은 값을 가지는 데이터를 말한다. 이상치는 극단적인 값을 갖기 때문에 분석의 결과에 아주 큰 영향을 주기도한다. 

* **결측치**는 이상치와는 다르게 어떠한 이유로 데이터가 존재하지 않는 값을 말한다. 보통 R 혹은 python 언어에서 결측치가 있는 데이터를 불러올 경우, **NA,NAN**으로 표시된다.

* 결측치와 이상치의 경우 일반적으로 제거하는 것이 해결방법으로 여겨진다. 하지만, 데이터가 매우 적은 경우에는 데이터를 함부로 제거해서는 안 된다. 따라서 이러한 경우, 평균값 혹은 적절한 데이터로 대체하는 방법이 있다. R에서는 `mice`함수를 지원하는데, 이 함수는 시뮬레이션을 통해 결측치에 대해서 적절한 값을 채워 넣어준다.



***
